class Solution {
    public int recursion(int i, int j, int remainder, int[][] grid, int k) {
        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length) return 0;
        if (i == grid.length - 1 && j == grid[0].length -1){
            if (((remainder+grid[i][j])%k) == 0) {
                return 1;
            }
            return 0;
        }
        int new_rem = (remainder+grid[i][j]) % k;
        int right = recursion(i, j+1, new_rem, grid, k);
        int down = recursion(i+1, j, new_rem, grid, k);
        return right+down % 1000000007; 
    }
    public int memoized(int i, int j, int remainder, int[][] grid, int k, int[][][] dp) {
        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length) return 0;
        if (i == grid.length - 1 && j == grid[0].length -1) {
            if(((remainder+grid[i][j])%k) == 0) {
                return 1;
            }
            else return 0;
        }
        if (dp[i][j][remainder] != -1) return dp[i][j][remainder];
        int new_rem = (remainder+grid[i][j]) % k;
        int right = memoized(i, j+1, new_rem, grid, k, dp);
        int down = memoized(i+1, j, new_rem, grid, k, dp);
        return dp[i][j][remainder] = (right+down) % 1000000007; 
    }
    public int numberOfPaths(int[][] grid, int k) {
        int[][][] dp = new int[grid.length][grid[0].length][k];
        for (int i = 0; i < grid.length;i++) {
            for(int j = 0; j < grid[0].length;j++) {
                Arrays.fill(dp[i][j], -1);
            }
        }
        return memoized(0, 0, 0, grid, k, dp);
    }
}
