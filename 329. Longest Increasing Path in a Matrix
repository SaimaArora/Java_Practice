class Solution {
    private int dfs(int r, int c, int[][] matrix, int[][] memo) {
        if(memo[r][c] != 0) return memo[r][c];
        int[] rows = {0, 0, -1, 1};
        int[] cols = {1, -1, 0, 0};
        int maxPath = 0;
        for(int i = 0; i < 4; i++) {
            int nr = r + rows[i], nc = c + cols[i];
            if(nr < 0 || nc < 0 || nr >= matrix.length || nc >= matrix[0].length) {
                continue;
            }
            if(matrix[nr][nc] > matrix[r][c]) maxPath = Math.max(maxPath, dfs(nr, nc, matrix, memo));
        }
        return memo[r][c] = 1 + maxPath;
    }
    public int longestIncreasingPath(int[][] matrix) {
        int m = matrix.length, maxAns = 0, n = matrix[0].length;
        int[][] memo = new int[m][n];
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                maxAns = Math.max(dfs(i, j, matrix, memo), maxAns);
            }
        }
        return maxAns;
    }
}
