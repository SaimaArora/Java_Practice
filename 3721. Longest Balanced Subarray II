class SegmentTree{
    int n;
    int[] min, max, lazy;
    public SegmentTree(int n) {
        this.n = n;
        min = new int[4*n];
        max = new int[4*n];
        lazy = new int[4*n];
    }
    public void update(int l, int r, int val) {
        updateRange(0, l, r, 0, n -1, val);
    }
    private void updateRange(int node, int l, int r, int low, int high, int val) {
        if(low > r || high < l) return;
        //complete
        if (low >= l && high <= r) {
            min[node] +=val;
            max[node] +=val;
            lazy[node] +=val;
            return;
        }
        pushDown(node);
        int mid = (low+high)/2;
        updateRange(2*node+1, l, r, low, mid, val);
        updateRange(2*node+2, l, r, mid+1, high, val);

        min[node] = Math.min(min[2*node+1], min[2*node+2]);
        max[node] = Math.max(max[2*node+1], max[2*node+2]);
    }
    private void pushDown(int node) {
        if (lazy[node] != 0) {
            int left = 2*node+1;
            int right = 2*node+2;
            min[left] += lazy[node];
            max[left] += lazy[node];
            lazy[left] += lazy[node];

            min[right] += lazy[node];
            max[right] += lazy[node];
            lazy[right] += lazy[node];

            lazy[node] = 0;
        }
    }
    public int firstZero(int rLimit) {
        return findFirstZero(0, 0, n - 1, rLimit);
    }
    private int findFirstZero(int node, int start, int end, int rLimit) {
        if (start > rLimit || min[node] > 0 || max[node] < 0) {
            return -1;
        }
        //leaf
        if (start == end) {
            return (min[node] == 0) ? start : -1;
        }
        pushDown(node);
        int mid = (start+end)/2;
        int left = findFirstZero(2*node+1, start, mid, rLimit);
        if(left != -1) return left;
        return findFirstZero(2*node+2, mid+1, end, rLimit);
    }
}

class Solution {

    public int longestBalanced(int[] nums) {
        int n = nums.length;
        SegmentTree sg = new SegmentTree(n);
        Map<Integer, Integer> map = new HashMap<>();
        int maxLen = 0;
        for (int r = 0; r < nums.length; r++) {
            int val = (nums[r] %2 == 0) ? 1 : -1;
            int prev = -1;
            //when seen in past, 0-prev add -val
            if(map.containsKey(nums[r])) {
                prev = map.get(nums[r]);
                sg.update(0, prev, -val);
            }
            map.put(nums[r], r);

            //0-r add val
            sg.update(0, r, val);
            //find leftmost 0 in range
            int leftInd = sg.firstZero(r);
            if(leftInd != -1) {
                maxLen = Math.max(maxLen, r - leftInd + 1);
            }
        }
        return maxLen;
    }
}
