int recursionKnapsack(int[] value,int[] weights,int capacity,int n){
  if(n==0 || capacity==0){
    return 0;
  }
  if(weights[n-1]>capacity){
    recursionKnapsack(value,weights,capacity,n-1);
  }
  else{
    int includedWeight=value[n-1]+recursionKnapsack(value,weights,capacity-weights[n-1],n-1);
    int notIncludedWeight=recursionKnapsack(value,weights,capacity,n-1);
    return Math.max(includedWeight,notIncludedWeight);
  }
}


int memoizedKnapsack(int[] value,int[] weights,int[] dp,int capacity,int n){
  if(capacity==0 || n==0) return 0;
  if(dp[n][capacity]!=-1){
    return dp[n][capacity];
  }
  if(weights[n-1]>capacity){
    dp[n][capacity]=recursionKnapsack(value,weights,capacity,n-1);
    return dp[n][capacity];
  }
  else{
    int includedWeight=value[n-1]+recursionKnapsack(value,weights,capacity-weights[n-1],n-1);
    int notIncludedWeight=recursionKnapsack(value,weights,capacity,n-1);
    dp[n][capacity]= Math.max(includedWeight,notIncludedWeight);
    return dp[n][capacity];
  }
}



int tabulatedKnapsack(int[] value,int[] weights,int[] dp,int capacity,int n){
int [][] dp=new int[n+1][capacity+1];
for(int i=0;i<n;i++){
  for(int w=0;w<capacity;w++){
    if(i==0 || w==0){
      dp[i][w]=0;
    }
    else if(weights[i-1]<=w){
      int includedWeight=value[n-1]+dp[i-1][w-weights[i-1]];
      int notIncludedWeight=dp[i-1][w];
      dp[n][w]= Math.max(includedWeight,notIncludedWeight);
    }
    else{
      dp[i][w]=dp[i-1][w]
    }
  }
}
}

