class Solution {
    List<List<String>> res = new ArrayList<>();
    // Key: Child, Value: List of Parents that lead to this child on the shortest path
    Map<String, List<String>> parentMap = new HashMap<>();

    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        Set<String> dict = new HashSet<>(wordList);
        if (!dict.contains(endWord)) return res;
        
        // Remove beginWord from dict to avoid cycles back to start
        dict.remove(beginWord);

        // Map to store the shortest distance to each node found so far
        Map<String, Integer> steps = new HashMap<>();
        steps.put(beginWord, 0);

        Queue<String> q = new LinkedList<>();
        q.offer(beginWord);
        
        boolean found = false;
        int level = 0;

        // --- Phase 1: BFS to build the Parent Map ---
        while (!q.isEmpty() && !found) {
            int size = q.size();
            level++; // We are moving to the next level
            
            // We use this set to ensure we don't add the same word to the queue twice in the same level
            Set<String> visitedInCurrentLevel = new HashSet<>();

            for (int k = 0; k < size; k++) {
                String curr = q.poll();
                char[] arr = curr.toCharArray();

                for (int i = 0; i < arr.length; i++) {
                    char original = arr[i];
                    for (char c = 'a'; c <= 'z'; c++) {
                        if (c == original) continue;
                        arr[i] = c;
                        String next = new String(arr);

                        // If 'next' is in the dict, it's a valid word
                        if (dict.contains(next)) {
                            // If we haven't seen this word yet, OR we saw it at this exact current level
                            // (If we saw it at an earlier level, it's not a shortest path, so ignore)
                            if (!steps.containsKey(next) || steps.get(next) == level) {
                                
                                // Add edge to Parent Map
                                parentMap.putIfAbsent(next, new ArrayList<>());
                                parentMap.get(next).add(curr);

                                // If this is the first time seeing it, mark distance and add to queue
                                if (!steps.containsKey(next)) {
                                    steps.put(next, level);
                                    visitedInCurrentLevel.add(next);
                                    q.offer(next);
                                }
                            }
                            
                            if (next.equals(endWord)) found = true;
                        }
                    }
                    arr[i] = original;
                }
            }
            // Optimization: Remove visited words from dict to shrink search space
            dict.removeAll(visitedInCurrentLevel);
        }

        // --- Phase 2: DFS (Backtracking) from End to Start ---
        if (found) {
            List<String> path = new ArrayList<>();
            path.add(endWord);
            dfs(endWord, beginWord, path);
        }
        
        return res;
    }

    private void dfs(String curr, String target, List<String> path) {
        // Base Case: We reached the start word
        if (curr.equals(target)) {
            // Because we went End -> Start, we need to reverse the list
            List<String> correctOrder = new ArrayList<>(path);
            Collections.reverse(correctOrder);
            res.add(correctOrder);
            return;
        }

        // Look up the parents recorded during BFS
        // If no parents exist (shouldn't happen if logic is correct), just return
        if (!parentMap.containsKey(curr)) return;

        for (String parent : parentMap.get(curr)) {
            path.add(parent);
            dfs(parent, target, path);
            path.remove(path.size() - 1); // Backtrack
        }
    }
}
