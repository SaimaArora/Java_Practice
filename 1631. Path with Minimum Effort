class Solution {
    class Node{
        int diff, row, col;
        Node(int row, int col, int diff) {
            this.diff = diff;
            this.row = row;
            this.col = col;
        }
    }
    public int minimumEffortPath(int[][] heights) {
        PriorityQueue<Node> pq = new PriorityQueue<>((x, y) -> x.diff - y.diff);
        pq.offer(new Node(0, 0, 0));
        int m = heights.length, n = heights[0].length; 
        int[][] distance = new int[m][n];
        for(int i = 0; i < m; i++){
            Arrays.fill(distance[i] , Integer.MAX_VALUE);
        }
        distance[0][0] = 0;
        int rows[] = {0, -1, 1, 0};
        int cols[] = {1, 0, 0, -1};
        while (!pq.isEmpty()) {
            Node curr = pq.poll();
            int diff = curr.diff, r = curr.row, c = curr.col;
            if (diff > distance[r][c]) continue;
            if (r== m-1 && c == n-1) return distance[r][c];
            for (int i = 0; i < 4; i++) {
                int row = r + rows[i], col = c + cols[i];
                if (row < m && col < n && row >= 0 && col >= 0) {
                    int difference = Math.abs(heights[row][col] - heights[r][c]);
                    int newEffort =  Math.max(diff, difference);
                    if (newEffort < distance[row][col]) {
                        pq.offer(new Node(row, col, newEffort));
                        distance[row][col] = newEffort;
                    }
                }
            }
        }
        return distance[m-1][n-1];
    }
}
